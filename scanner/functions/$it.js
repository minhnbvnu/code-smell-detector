function $it(n,t,e,i){let r=n.getParameter(34921),o=i.isWebGL2?null:t.get("OES_vertex_array_object"),s=i.isWebGL2||o!==null,a={},l=m(null),c=l;function u(N,L,O,z,V){let $=!1;if(s){let X=f(z,O,L);c!==X&&(c=X,p(c.object)),$=x(z,V),$&&g(z,V)}else{let X=L.wireframe===!0;(c.geometry!==z.id||c.program!==O.id||c.wireframe!==X)&&(c.geometry=z.id,c.program=O.id,c.wireframe=X,$=!0)}N.isInstancedMesh===!0&&($=!0),V!==null&&e.update(V,34963),$&&(E(N,L,O,z),V!==null&&n.bindBuffer(34963,e.get(V).buffer))}function h(){return i.isWebGL2?n.createVertexArray():o.createVertexArrayOES()}function p(N){return i.isWebGL2?n.bindVertexArray(N):o.bindVertexArrayOES(N)}function d(N){return i.isWebGL2?n.deleteVertexArray(N):o.deleteVertexArrayOES(N)}function f(N,L,O){let z=O.wireframe===!0,V=a[N.id];V===void 0&&(V={},a[N.id]=V);let $=V[L.id];$===void 0&&($={},V[L.id]=$);let X=$[z];return X===void 0&&(X=m(h()),$[z]=X),X}function m(N){let L=[],O=[],z=[];for(let V=0;V<r;V++)L[V]=0,O[V]=0,z[V]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:L,enabledAttributes:O,attributeDivisors:z,object:N,attributes:{},index:null}}function x(N,L){let O=c.attributes,z=N.attributes,V=0;for(let $ in z){let X=O[$],W=z[$];if(X===void 0||X.attribute!==W||X.data!==W.data)return!0;V++}return c.attributesNum!==V||c.index!==L}function g(N,L){let O={},z=N.attributes,V=0;for(let $ in z){let X=z[$],W={};W.attribute=X,X.data&&(W.data=X.data),O[$]=W,V++}c.attributes=O,c.attributesNum=V,c.index=L}function v(){let N=c.newAttributes;for(let L=0,O=N.length;L<O;L++)N[L]=0}function b(N){y(N,0)}function y(N,L){let O=c.newAttributes,z=c.enabledAttributes,V=c.attributeDivisors;O[N]=1,z[N]===0&&(n.enableVertexAttribArray(N),z[N]=1),V[N]!==L&&((i.isWebGL2?n:t.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](N,L),V[N]=L)}function _(){let N=c.newAttributes,L=c.enabledAttributes;for(let O=0,z=L.length;O<z;O++)L[O]!==N[O]&&(n.disableVertexAttribArray(O),L[O]=0)}function S(N,L,O,z,V,$){i.isWebGL2===!0&&(O===5124||O===5125)?n.vertexAttribIPointer(N,L,O,V,$):n.vertexAttribPointer(N,L,O,z,V,$)}function E(N,L,O,z){if(i.isWebGL2===!1&&(N.isInstancedMesh||z.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;v();let V=z.attributes,$=O.getAttributes(),X=L.defaultAttributeValues;for(let W in $){let K=$[W];if(K.location>=0){let Z=V[W];if(Z===void 0&&(W==="instanceMatrix"&&N.instanceMatrix&&(Z=N.instanceMatrix),W==="instanceColor"&&N.instanceColor&&(Z=N.instanceColor)),Z!==void 0){let Y=Z.normalized,tt=Z.itemSize,q=e.get(Z);if(q===void 0)continue;let et=q.buffer,it=q.type,at=q.bytesPerElement;if(Z.isInterleavedBufferAttribute){let nt=Z.data,_t=nt.stride,vt=Z.offset;if(nt&&nt.isInstancedInterleavedBuffer){for(let rt=0;rt<K.locationSize;rt++)y(K.location+rt,nt.meshPerAttribute);N.isInstancedMesh!==!0&&z._maxInstanceCount===void 0&&(z._maxInstanceCount=nt.meshPerAttribute*nt.count)}else for(let rt=0;rt<K.locationSize;rt++)b(K.location+rt);n.bindBuffer(34962,et);for(let rt=0;rt<K.locationSize;rt++)S(K.location+rt,tt/K.locationSize,it,Y,_t*at,(vt+tt/K.locationSize*rt)*at)}else{if(Z.isInstancedBufferAttribute){for(let nt=0;nt<K.locationSize;nt++)y(K.location+nt,Z.meshPerAttribute);N.isInstancedMesh!==!0&&z._maxInstanceCount===void 0&&(z._maxInstanceCount=Z.meshPerAttribute*Z.count)}else for(let nt=0;nt<K.locationSize;nt++)b(K.location+nt);n.bindBuffer(34962,et);for(let nt=0;nt<K.locationSize;nt++)S(K.location+nt,tt/K.locationSize,it,Y,tt*at,tt/K.locationSize*nt*at)}}else if(X!==void 0){let Y=X[W];if(Y!==void 0)switch(Y.length){case 2:n.vertexAttrib2fv(K.location,Y);break;case 3:n.vertexAttrib3fv(K.location,Y);break;case 4:n.vertexAttrib4fv(K.location,Y);break;default:n.vertexAttrib1fv(K.location,Y)}}}}_()}function M(){w();for(let N in a){let L=a[N];for(let O in L){let z=L[O];for(let V in z)d(z[V].object),delete z[V];delete L[O]}delete a[N]}}function P(N){if(a[N.id]===void 0)return;let L=a[N.id];for(let O in L){let z=L[O];for(let V in z)d(z[V].object),delete z[V];delete L[O]}delete a[N.id]}function D(N){for(let L in a){let O=a[L];if(O[N.id]===void 0)continue;let z=O[N.id];for(let V in z)d(z[V].object),delete z[V];delete O[N.id]}}function w(){I(),c!==l&&(c=l,p(c.object))}function I(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:u,reset:w,resetDefaultState:I,dispose:M,releaseStatesOfGeometry:P,releaseStatesOfProgram:D,initAttributes:v,enableAttribute:b,disableUnusedAttributes:_}}