function L0e(e,t,r){let n=Lr(f=>{let h=r.current,p;switch(f.inputType){case"historyUndo":case"historyRedo":return;case"deleteContent":case"deleteByCut":case"deleteByDrag":p=h.value.slice(0,h.selectionStart)+h.value.slice(h.selectionEnd);break;case"deleteContentForward":p=h.selectionEnd===h.selectionStart?h.value.slice(0,h.selectionStart)+h.value.slice(h.selectionEnd+1):h.value.slice(0,h.selectionStart)+h.value.slice(h.selectionEnd);break;case"deleteContentBackward":p=h.selectionEnd===h.selectionStart?h.value.slice(0,h.selectionStart-1)+h.value.slice(h.selectionStart):h.value.slice(0,h.selectionStart)+h.value.slice(h.selectionEnd);break;case"deleteSoftLineBackward":case"deleteHardLineBackward":p=h.value.slice(h.selectionStart);break;default:f.data!=null&&(p=h.value.slice(0,h.selectionStart)+f.data+h.value.slice(h.selectionEnd));break}(p==null||!t.validate(p))&&f.preventDefault()});O.useEffect(()=>{if(!M_())return;let f=r.current;return f.addEventListener("beforeinput",n,!1),()=>{f.removeEventListener("beforeinput",n,!1)}},[r,n]);let i=M_()?null:f=>{let h=f.target.value.slice(0,f.target.selectionStart)+f.data+f.target.value.slice(f.target.selectionEnd);t.validate(h)||f.preventDefault()},{labelProps:a,inputProps:l,descriptionProps:s,errorMessageProps:u,...c}=H1(e,r),d=O.useRef(null);return{inputProps:$e(l,{onBeforeInput:i,onCompositionStart(){let{value:f,selectionStart:h,selectionEnd:p}=r.current;d.current={value:f,selectionStart:h,selectionEnd:p}},onCompositionEnd(){if(!t.validate(r.current.value)){let{value:f,selectionStart:h,selectionEnd:p}=d.current;r.current.value=f,r.current.setSelectionRange(h,p),t.setInputValue(f)}}}),labelProps:a,descriptionProps:s,errorMessageProps:u,...c}}