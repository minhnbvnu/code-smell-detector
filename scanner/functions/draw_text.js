function draw_text(font, str, pos, color, shadow, outline, x_align, y_align, z, wrap_width, text_size, markup) {
    // Cannot skip in off frames because it has a return value
    
    if (font && (font.text !== undefined || font.font !== undefined || font.pos !== undefined)) {
        // Keyword version
        text_size = font.text_size;
        wrap_width = font.wrap_width;
        z = font.z;
        y_align = font.y_align;
        x_align = font.x_align;
        outline = font.outline;
        shadow = font.shadow;
        color = font.color;
        pos = font.pos;
        str = font.text;
        markup = font.markup;
        font = font.font;
    }

    if (font === undefined) {
        // Default font
        font = $font8;
    }
    
    if (font.$url === undefined) {
        $error('draw_text() font argument must be a font or nil');
    }
    
    if (pos === undefined) {
        $error('draw_text() requires a pos');
    }

    if (typeof str !== 'string') {
        str = unparse(str);
    }
    
    let z_order = z;
    if (z_order === undefined) { z_order = pos.z; }
    if (z_order === undefined) { z_order = 0; }
    let z_pos = pos.z;
    if (z_pos === undefined) { z_pos = z_order; }

    z_order -= $camera.z;
    z_pos -= $camera.z;

    if (($camera.x !== 0) || ($camera.y !== 0) || ($camera.angle !== 0) || ($camera.zoom !== 1)) {
        // Transform the arguments to account for the camera
        const mag = $zoom(z_pos);
        const C = $Math.cos($camera.angle) * mag, S = $Math.sin($camera.angle * rotation_sign()) * mag;
        const x = pos.x - $camera.x, y = pos.y - $camera.y;
        pos = {x: x * C + y * S, y: y * C - x * S};
    }

    if (str === '') { return {pos: {x:pos.x, y:pos.y}, size: {x: 0, y: 0}, height:0, z:z_order}; }
    
    const stateChanges = [{
        font:       font,
        color:      $colorToUint16(color),
        shadow:     $colorToUint16(shadow),
        outline:    $colorToUint16(outline),
        startIndex: 0,
        endIndex:   str.length - 1
    }];
    
    if (markup) {
        str = $parseMarkup(str, stateChanges);
    }

    if (text_size === undefined) {
        text_size = str.length;
    }

    switch (x_align) {
    case 'middle': case 'center': x_align = 0; break;
    case 'right':  x_align = +1; break;
    case 'left': x_align = -1; break;
    default:
        if (x_align !== 0 && x_align !== 1 && x_align !== -1) {
            x_align = 0;
        }
        break;
    }

    switch (y_align) {
    case 'top': y_align = -1; break;
    case 'center': case 'middle': y_align = 0; break;
    case 'bottom': y_align = +2; break;
    case 'baseline': y_align = +1; break;
    default:
        if (y_align !== 0 && y_align !== 1 && y_align !== -1 && y_align !== 2) {
            y_align = 0;
        }
        
    }
    
    // Debug visualize the markup:
    /*
    if (markup) {
        for (let i = 0; i < stateChanges.length; ++i) {
            $console.log(str.substring(stateChanges[i].startIndex, stateChanges[i].endIndex + 1), stateChanges[i]);
        }
    }
    */

    // Track draw calls generated by $draw_text
    const first_graphics_command_index = $graphicsCommandList.length;
    const bounds = $draw_text(0, 0, str, stateChanges, pos, z_pos, x_align, y_align, z_order, wrap_width, text_size, font);

    if (first_graphics_command_index === $graphicsCommandList.length) {
        // Drew nothing!
        return {pos:{x:pos.x, y:pos.y}, size:{x:0, y:0}, height:bounds.size.y, z:z_order};
    }

    // Compute bounds in screen space
    {
        let i = first_graphics_command_index;
        bounds.pos = {x: $graphicsCommandList[i].x, y: $graphicsCommandList[i].y};
        ++i;
        while (i < $graphicsCommandList.length) {
            bounds.pos.x = $Math.min(bounds.pos.x, $graphicsCommandList[i].x);
            bounds.pos.y = $Math.min(bounds.pos.y, $graphicsCommandList[i].y);
            ++i;
        }
        
        // Move to the center
        bounds.pos.x += 0.5 * bounds.size.x + 0.5;
        bounds.pos.y += 0.5 * bounds.size.y + 0.5;
    }
    bounds.z = z_order;

    if ((bounds.size.y > font.line_height) && (y_align === 0 || y_align === 2)) {
        let y_shift = 0;
        if (y_align === 0) {
            // Center
            y_shift = 0.5 * (font.line_height - bounds.size.y);
        } else {
            // Bottom
            y_shift = font.line_height - bounds.size.y;
        }
        bounds.pos.y += y_shift;
        
        // Multiline needing vertical adjustment. Go back to the issued
        // draw calls and shift them vertically as required.
        for (let i = first_graphics_command_index; i < $graphicsCommandList.length; ++i) {
            $graphicsCommandList[i].y += y_shift;
        }
    }

    // Preserve the height for layout
    bounds.height = bounds.size.y;
    
    // Enforce the clipping region on the bounds
    {
        let minX = $Math.max(bounds.pos.x - 0.5 * bounds.size.x, $clipX1);
        let maxX = $Math.min(bounds.pos.x + 0.5 * bounds.size.x, $clipX2);
        let minY = $Math.max(bounds.pos.y - 0.5 * bounds.size.y, $clipY1);
        let maxY = $Math.min(bounds.pos.y + 0.5 * bounds.size.y, $clipY2);

        bounds.pos.x = 0.5 * (maxX + minX);
        bounds.size.x = maxX - minX;
        bounds.pos.y = 0.5 * (maxY + minY);
        bounds.size.y = maxY - minY;
        if (bounds.size.x <= 0 || bounds.size.y <= 0) {
            bounds.size.x = bounds.size.y = bounds.pos.x = bounds.pos.y = NaN;
        }
    }
    
    // Convert screen space pos to camera space
    bounds.pos.x = (bounds.pos.x - $offsetX) / $scaleX - bounds.z * $skewXZ;
    bounds.pos.y = (bounds.pos.y - $offsetY) / $scaleY - bounds.z * $skewYZ;
    
    return bounds;
}