function qQ(n){let{inputs:t,backend:e,attrs:i}=n,{x:r,segmentIds:o}=t,{numSegments:s}=i,a=r.shape.length,l=[],c=0,u=F.getAxesPermutation([c],a),h=r;u!=null&&(h=Pe({inputs:{x:r},backend:e,attrs:{perm:u}}),l.push(h),c=F.getInnerMostAxes(1,a)[0]);let p=F.segment_util.computeOutShape(h.shape,c,s),d=R.sizeFromShape([h.shape[c]]),f=Et({inputs:{x:h},backend:e,attrs:{shape:[-1,d]}});l.push(f);let m=Qs(r.dtype),x=(y,_,S,E,M)=>{let P=y.shape[0],D=y.shape[1],w=F.segment_util.segOpComputeOptimalWindowSize(D,M),I={windowSize:w,inSize:D,batchSize:P,numSegments:M},N=new lx(I,_),L=e.compileAndRun(N,[y,S],E);if(l.push(L),L.shape[1]===M)return L;let O=Ew({backend:e,attrs:{start:0,stop:M,step:1,dtype:"float32"}}),z=Tw({inputs:{x:O},backend:e,attrs:{reps:[D/w]}});return l.push(O),l.push(z),x(L,_,z,E,M)},g=x(f,"unsortedSegmentSum",o,m,s),v=Et({inputs:{x:g},backend:e,attrs:{shape:p}}),b=v;if(u!=null){l.push(v);let y=F.getUndoAxesPermutation(u);b=Pe({inputs:{x:b},backend:e,attrs:{perm:y}})}return l.forEach(y=>e.disposeIntermediateTensorInfo(y)),b}