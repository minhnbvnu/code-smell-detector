function uX(n){let{inputs:t,backend:e,attrs:i}=n,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:a}=i;ut(r,"resizeBilinear");let l=R.computeStrides(r.shape),[c,u]=a,[h,p,d,f]=r.shape,m=e.data.get(r.dataId).values,x=new Float32Array(R.sizeFromShape([h,c,u,f])),g=[o&&c>1?p-1:p,o&&u>1?d-1:d],v=[o&&c>1?c-1:c,o&&u>1?u-1:u],b=0,y=g[0]/v[0],_=g[1]/v[1];for(let S=0;S<h;S++)for(let E=0;E<c;E++){let M;s?M=y*(E+.5)-.5:M=y*E;let P=Math.max(0,Math.floor(M)),D=M-P,w=Math.min(p-1,Math.ceil(M)),I=S*l[0]+P*l[1],N=S*l[0]+w*l[1];for(let L=0;L<u;L++){let O;s?O=_*(L+.5)-.5:O=_*L;let z=Math.max(0,Math.floor(O)),V=O-z,$=Math.min(d-1,Math.ceil(O)),X=I+z*l[2],W=N+z*l[2],K=I+$*l[2],Z=N+$*l[2];for(let Y=0;Y<f;Y++){let tt=m[X+Y],q=m[W+Y],et=m[K+Y],it=m[Z+Y],at=tt+(et-tt)*V,nt=q+(it-q)*V,_t=at+(nt-at)*D;x[b++]=_t}}}return e.makeTensorInfo([h,c,u,f],"float32",x)}