function FX(n){let{inputs:t,attrs:e,backend:i}=n,{image:r,transforms:o}=t,{interpolation:s,fillMode:a,fillValue:l,outputShape:c}=e,[u,h,p,d]=r.shape,[f,m]=c!=null?c:[h,p],x=[u,f,m,d],g=R.computeStrides(r.shape),v=g[0],b=g[1],y=g[2],_=R.getTypedArrayFromDType(r.dtype,R.sizeFromShape(x));_.fill(l);let S=i.data.get(r.dataId).values,E=i.data.get(o.dataId).values;for(let P=0;P<u;++P){let D=o.shape[0]===1?E:E.subarray(P*8,P*8+8);for(let w=0;w<f;++w)for(let I=0;I<m;++I)for(let N=0;N<d;++N){let L,O=D[6]*I+D[7]*w+1;if(O===0)continue;let z=(D[0]*I+D[1]*w+D[2])/O,V=(D[3]*I+D[4]*w+D[5])/O,$=ZR(z,p,a),X=ZR(V,h,a);switch(s){case"nearest":L=$X(S,h,p,v,b,y,P,X,$,N,l);break;case"bilinear":L=UX(S,h,p,v,b,y,P,X,$,N,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${s}`)}let W=P*v+w*b+I*y+N;_[W]=L}return i.makeTensorInfo(x,r.dtype,_)}return{dataId:i.write(_,x,r.dtype),shape:r.shape,dtype:r.dtype}}