function RadialAxialShading(t,o,l,h,d){var y;_classCallCheck(this,RadialAxialShading);(y=r.call(this)).coordsArr=t.getArray("Coords");y.shadingType=t.get("ShadingType");var m=u.ColorSpace.parse({cs:t.getRaw("CS")||t.getRaw("ColorSpace"),xref:o,resources:l,pdfFunctionFactory:h,localColorSpaceCache:d}),v=t.getArray("BBox");Array.isArray(v)&&4===v.length?y.bbox=c.Util.normalizeRect(v):y.bbox=null;var w=0,_=1;if(t.has("Domain")){var S=t.getArray("Domain");w=S[0];_=S[1]}var C=!1,x=!1;if(t.has("Extend")){var O=t.getArray("Extend");C=O[0];x=O[1]}if(!(y.shadingType!==g||C&&x)){var T=_slicedToArray(y.coordsArr,6),E=T[0],M=T[1],R=T[2],L=T[3],j=T[4],D=T[5],N=Math.hypot(E-L,M-j);R<=D+N&&D<=R+N&&(0,c.warn)("Unsupported radial gradient.")}y.extendStart=C;y.extendEnd=x;var U=t.getRaw("Function"),H=h.createFromArray(U),G=(_-w)/10,$=y.colorStops=[];if(w>=_||G<=0){(0,c.info)("Bad shading domain.");return _possibleConstructorReturn(y)}for(var X,q=new Float32Array(m.numComps),z=new Float32Array(1),W=0;W<=10;W++){z[0]=w+W*G;H(z,0,q,0);X=m.getRgb(q,0);var V=c.Util.makeHexColor(X[0],X[1],X[2]);$.push([W/10,V])}var K="transparent";if(t.has("Background")){X=m.getRgb(t.get("Background"),0);K=c.Util.makeHexColor(X[0],X[1],X[2])}if(!C){$.unshift([0,K]);$[1][0]+=k.SMALL_NUMBER}if(!x){$.at(-1)[0]-=k.SMALL_NUMBER;$.push([1,K])}y.colorStops=$;return y}