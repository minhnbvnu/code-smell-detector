function topoSort(graph)
{
    // Count the number of input edges going into a node
    function countInEdges(nodeId)
    {
        let node = graph.nodes[nodeId];
        let numIns = 0;

        for (let i = 0; i < node.ins.length; ++i)
        {
            let edge = node.ins[i];

            if (!edge)
                continue;

            if (remEdges.has(edge))
                continue;

            numIns++;
        }

        return numIns;
    }

    // Set of nodes with no incoming edges
    let S = [];

    // List sorted in reverse topological order
    let L = [];

    // Map of input-side edges removed from the graph
    let remEdges = new WeakSet();

    // Map of each node to a list of outgoing edges
    let outEdges = new Map();

    // Populate the initial list of nodes without input edges
    for (let nodeId in graph.nodes)
    {
        if (countInEdges(nodeId) == 0)
        {
            S.push(nodeId);
        }
    }

    // Initialize the set of list of output edges for each node
    for (let nodeId in graph.nodes)
    {
        outEdges.set(nodeId, []);
    }

    // Populate the list of output edges for each node
    for (let nodeId in graph.nodes)
    {
        let node = graph.nodes[nodeId];

        // For each input of this node
        for (let i = 0; i < node.ins.length; ++i)
        {
            let edge = node.ins[i];

            if (!edge)
                continue;

            let [srcId, srcPort] = node.ins[i];
            let srcOuts = outEdges.get(srcId);
            srcOuts.push([nodeId, edge]);
        }
    }

    // While we have nodes with no inputs
    while (S.length > 0)
    {
        // Remove a node from S, add it at the end of L
        var nodeId = S.pop();
        L.push(nodeId);

        // Get the list of output edges for this node
        let nodeOuts = outEdges.get(nodeId);

        // For each outgoing edge
        for (let [dstId, edge] of nodeOuts)
        {
            // Mark the edge as removed
            remEdges.add(edge);

            // If the node has no more incoming edges
            if (countInEdges(dstId) == 0)
                S.push(dstId);
        }
    }

    // If the topological ordering doesn't include all the nodes
    if (L.length != Object.keys(graph.nodes).length)
    {
        throw SyntaxError('graph contains cycles');
    }

    return L;
}