function isTypeDerivedFrom(source, target) {
                return source.flags & 1048576 /* Union */ ? every(source.types, (t) => isTypeDerivedFrom(t, target)) : target.flags & 1048576 /* Union */ ? some(target.types, (t) => isTypeDerivedFrom(source, t)) : source.flags & 2097152 /* Intersection */ ? some(source.types, (t) => isTypeDerivedFrom(t, target)) : source.flags & 58982400 /* InstantiableNonPrimitive */ ? isTypeDerivedFrom(getBaseConstraintOfType(source) || unknownType, target) : isEmptyAnonymousObjectType(target) ? !!(source.flags & (524288 /* Object */ | 67108864 /* NonPrimitive */)) : target === globalObjectType ? !!(source.flags & (524288 /* Object */ | 67108864 /* NonPrimitive */)) && !isEmptyAnonymousObjectType(source) : target === globalFunctionType ? !!(source.flags & 524288 /* Object */) && isFunctionObjectType(source) : hasBaseType(source, getTargetType(target)) || isArrayType(target) && !isReadonlyArrayType(target) && isTypeDerivedFrom(source, globalReadonlyArrayType);
            }