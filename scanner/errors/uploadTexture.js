function uploadTexture( textureProperties, texture, slot ) {

    		let textureType = 3553;

    		if ( texture.isDataTexture2DArray ) textureType = 35866;
    		if ( texture.isDataTexture3D ) textureType = 32879;

    		initTexture( textureProperties, texture );

    		state.activeTexture( 33984 + slot );
    		state.bindTexture( textureType, textureProperties.__webglTexture );

    		_gl.pixelStorei( 37440, texture.flipY );
    		_gl.pixelStorei( 37441, texture.premultiplyAlpha );
    		_gl.pixelStorei( 3317, texture.unpackAlignment );
    		_gl.pixelStorei( 37443, 0 );

    		const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1( texture.image ) === false;
    		const image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

    		const supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
    			glFormat = utils.convert( texture.format );

    		let glType = utils.convert( texture.type ),
    			glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );

    		setTextureParameters( textureType, texture, supportsMips );

    		let mipmap;
    		const mipmaps = texture.mipmaps;

    		if ( texture.isDepthTexture ) {

    			// populate depth texture with dummy data

    			glInternalFormat = 6402;

    			if ( isWebGL2 ) {

    				if ( texture.type === FloatType ) {

    					glInternalFormat = 36012;

    				} else if ( texture.type === UnsignedIntType ) {

    					glInternalFormat = 33190;

    				} else if ( texture.type === UnsignedInt248Type ) {

    					glInternalFormat = 35056;

    				} else {

    					glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

    				}

    			} else {

    				if ( texture.type === FloatType ) {

    					console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

    				}

    			}

    			// validation checks for WebGL 1

    			if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

    				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
    				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
    				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
    				if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

    					console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

    					texture.type = UnsignedShortType;
    					glType = utils.convert( texture.type );

    				}

    			}

    			if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

    				// Depth stencil textures need the DEPTH_STENCIL internal format
    				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
    				glInternalFormat = 34041;

    				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
    				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
    				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
    				if ( texture.type !== UnsignedInt248Type ) {

    					console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

    					texture.type = UnsignedInt248Type;
    					glType = utils.convert( texture.type );

    				}

    			}

    			//

    			state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

    		} else if ( texture.isDataTexture ) {

    			// use manually created mipmaps if available
    			// if there are no manual mipmaps
    			// set 0 level mipmap and then use GL to generate other mipmap levels

    			if ( mipmaps.length > 0 && supportsMips ) {

    				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

    					mipmap = mipmaps[ i ];
    					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    				}

    				texture.generateMipmaps = false;

    			} else {

    				state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );

    			}

    		} else if ( texture.isCompressedTexture ) {

    			for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

    				mipmap = mipmaps[ i ];

    				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

    					if ( glFormat !== null ) {

    						state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

    					} else {

    						console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

    					}

    				} else {

    					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    				}

    			}

    		} else if ( texture.isDataTexture2DArray ) {

    			state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

    		} else if ( texture.isDataTexture3D ) {

    			state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

    		} else {

    			// regular Texture (image, video, canvas)

    			// use manually created mipmaps if available
    			// if there are no manual mipmaps
    			// set 0 level mipmap and then use GL to generate other mipmap levels

    			const levels = getMipLevels( texture, image, supportsMips );
    			const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
    			const allocateMemory = ( textureProperties.__version === undefined );

    			if ( mipmaps.length > 0 && supportsMips ) {

    				if ( useTexStorage && allocateMemory ) {

    					state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

    				}

    				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

    					mipmap = mipmaps[ i ];

    					if ( useTexStorage ) {

    						state.texSubImage2D( 3553, i, 0, 0, glFormat, glType, mipmap );

    					} else {

    						state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

    					}

    				}

    				texture.generateMipmaps = false;

    			} else {

    				if ( useTexStorage ) {

    					if ( allocateMemory ) {

    						state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

    					}

    					state.texSubImage2D( 3553, 0, 0, 0, glFormat, glType, image );

    				} else {

    					state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );

    				}

    			}

    		}

    		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

    			generateMipmap( textureType );

    		}

    		textureProperties.__version = texture.version;

    		if ( texture.onUpdate ) texture.onUpdate( texture );

    	}