  await promiseRetry(async (retry, times) => {
    try {
      const ag = await getCloudApiClient();

      const result = await ag.describeApis({
        ApiName: apiName,
        GroupId: group.GroupId
      });

      debug(`describeApis response: ${JSON.stringify(result)}`);

      var apiSummarys = result.ApiSummarys && result.ApiSummarys.ApiSummary;
      var api;

      if (apiSummarys) {
        api = apiSummarys.find(summary => summary.ApiName === apiName);
      }

      const mergedRequestConfig = Object.assign(getDefaultRequestConfig(method), {
        'requestHttpMethod': method,
        'requestPath': requestPath
      }, requestConfig);

      const { apiRequestParameters,
        apiServiceParameters,
        apiServiceParametersMap } = processApiParameters(requestParameters, serviceParameters, serviceParametersMap);

      const profile = await getProfile();

      var params = {
        GroupId: group.GroupId,
        ApiName: apiName,
        Visibility: visibility,
        Description: description || 'The awesome api generated by fun',
        AuthType: auth.type || 'ANONYMOUS',
        RequestConfig: JSON.stringify(mergedRequestConfig),
        RequestParameters: JSON.stringify(apiRequestParameters),
        ServiceParameters: JSON.stringify(apiServiceParameters),
        ServiceParametersMap: JSON.stringify(apiServiceParametersMap),
        ServiceConfig: JSON.stringify({
          'ServiceProtocol': 'FunctionCompute',
          'ContentTypeValue': 'application/x-www-form-urlencoded; charset=UTF-8',
          'Mock': 'FALSE',
          'MockResult': '',
          'ServiceAddress': '',
          'ServicePath': '',
          'ServiceHttpMethod': '',
          'ContentTypeCatagory': 'DEFAULT',
          'ServiceVpcEnable': 'FALSE',
          'ServiceTimeout': serviceTimeout,
          FunctionComputeConfig: {
            FcRegionId: profile.defaultRegion,
            ServiceName: serviceName,
            FunctionName: functionName,
            RoleArn: roleArn
          }
        }),
        ResultType: resultConfig.resultType || 'passthrough',
        ResultSample: resultConfig.resultSample || 'result sample',
        FailResultSample: resultConfig.failResultSample || 'failed samples',
        DisableInternet: disableInternet || false,
        ErrorCodeSamples: _.isEmpty(errorCodeSamples) ? [] : JSON.stringify(errorCodeSamples)
      };

      if (allowSignatureMethod) {
        Object.assign(params, {
          'allowSignatureMethod': allowSignatureMethod
        });
      }

      if (webSocketApiType) {
        Object.assign(params, {
          'WebSocketApiType': webSocketApiType
        });
      }

      if (appCodeAuthType) {
        Object.assign(params, {
          'AppCodeAuthType': appCodeAuthType
        });
      }

      if (auth.type === 'APPOPENID' || auth.type === 'OPENID') {
        var openidConf = auth.config || {};
        params.OpenIdConnectConfig = JSON.stringify({
          'IdTokenParamName': openidConf.idTokenParamName,
          'OpenIdApiType': openidConf.openIdApiType || 'BUSINESS',
          'PublicKeyId': openidConf.publicKeyId,
          'PublicKey': openidConf.publicKey
        });
      }

      if (forceNonceCheck !== undefined) {
        Object.assign(params, {
          ForceNonceCheck: forceNonceCheck
        });
      }

      debug('api params is %j', params);

      if (!api) {
        debug('create api');
        api = await ag.createApi(params);
      } else {
        debug('modify api');
        await ag.modifyApi(Object.assign(params, {
          ApiId: api.ApiId
        }));
      }

      debug('deploy api, params is GroupId %s, ApiId %s, StageName: %s', group.GroupId, api.ApiId, stageName);

      await ag.deployApi({
        GroupId: group.GroupId,
        ApiId: api.ApiId,
        StageName: stageName,
        Description: `deployed by fun at ${new Date().toISOString()}`
      });

      const apiDetail = await ag.describeApi({
        GroupId: group.GroupId,
        ApiId: api.ApiId
      });

      console.log('    URL: %s %s://%s%s',
        green(apiDetail.RequestConfig.RequestHttpMethod),
        apiDetail.RequestConfig.RequestProtocol.toLowerCase(),
        group.SubDomain,
        apiDetail.RequestConfig.RequestPath);
      apiDetail.DeployedInfos.DeployedInfo.forEach((info) => {
        if (info.DeployedStatus === 'DEPLOYED') {
          console.log(green(`      stage: ${info.StageName}, deployed, version: ${info.EffectiveVersion}`));
        } else {
          console.log(`      stage: ${info.StageName}, undeployed`);
        }
      });
    } catch (ex) {
      if (ex.code === 'DuplicateRequestParamaters') {
        throw new Error(red(ex.message));
      } else {
        debug('error when makeApi, error is: \n%O', ex);

        console.log(red(ex.message));
        console.log(red(`\tretry ${times} times`));
        retry(ex);
      }
      scrollTo;
    }
  });